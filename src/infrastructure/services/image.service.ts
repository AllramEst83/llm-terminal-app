import { GoogleGenAI, Modality } from "@google/genai";
import type { GeminiUsageMetadata } from "../api/gemini.service";
import { TokenCountService } from "./token-count.service";
import { ModelService, type ImageAspectRatio, type ImageModelDefinition } from "./model.service";

function getAiInstance(apiKey: string) {
  if (!apiKey) {
    throw new Error("API_KEY not provided");
  }
  return new GoogleGenAI({ apiKey: apiKey });
}

export interface ImageGenerationResult {
  imageData: string;
  usageMetadata?: GeminiUsageMetadata;
}

export async function generateImage(
  prompt: string,
  apiKey: string,
  aspectRatio: string = '1:1',
  model?: string
): Promise<ImageGenerationResult> {
  if (!apiKey) {
    throw new Error("API key is missing. Please configure your API key.");
  }

  const selectedModel =
    ModelService.resolveImageModel(model) ?? ModelService.getDefaultImageModel();

  if (!/^\d+:\d+$/.test(aspectRatio)) {
    throw new Error(
      `Invalid aspect ratio format: "${aspectRatio}". Use format like "1:1", "16:9", "9:16", etc.`
    );
  }

  const aspectRatioValue = aspectRatio as ImageAspectRatio;
  if (
    !selectedModel.supportedAspectRatios.includes(aspectRatioValue)
  ) {
    throw new Error(
      `Aspect ratio "${aspectRatio}" is not supported by ${selectedModel.displayName}. Supported: ${selectedModel.supportedAspectRatios.join(', ')}.`
    );
  }

  const ai = getAiInstance(apiKey);

  try {
    return await executeModelGeneration({
      ai,
      model: selectedModel,
      prompt,
      apiKey,
      aspectRatio: aspectRatioValue,
    });
  } catch (error) {
    console.error(`Error generating image via ${selectedModel.id} API:`, error);
    if (error instanceof Error) {
      throw new Error(`Failed to generate image: ${error.message}`);
    }
    throw new Error("Failed to generate image. The API returned an error.");
  }
}

interface ModelGenerationOptions {
  ai: GoogleGenAI;
  model: ImageModelDefinition;
  prompt: string;
  apiKey: string;
  aspectRatio: ImageAspectRatio;
}

async function executeModelGeneration({
  ai,
  model,
  prompt,
  apiKey,
  aspectRatio,
}: ModelGenerationOptions): Promise<ImageGenerationResult> {
  if (model.inputTokenLimit) {
    if (model.tokenCountModelId) {
      try {
        const tokenCount = await TokenCountService.countTokensViaEndpoint(
          prompt,
          apiKey,
          model.tokenCountModelId
        );

        if (tokenCount > model.inputTokenLimit) {
          throw new Error(
            `Prompt exceeds ${model.displayName} token limit (${tokenCount.toLocaleString()} > ${model.inputTokenLimit.toLocaleString()}). Please shorten your prompt.`
          );
        }
      } catch (error) {
        console.warn(
          `Failed to count tokens via endpoint for ${model.displayName}, continuing with request:`,
          error
        );
      }
    } else {
      const estimatedTokens = Math.ceil(prompt.length / 4);
      
      if (estimatedTokens > model.inputTokenLimit) {
        throw new Error(
          `Prompt appears to exceed ${model.displayName} token limit (estimated ${estimatedTokens.toLocaleString()} > ${model.inputTokenLimit.toLocaleString()} tokens). Please shorten your prompt.`
        );
      }
    }
  }

  if (model.generationMethod === 'generateContent') {
    const response = await ai.models.generateContent({
      model: model.apiModelId,
      contents: {
        parts: [{ text: prompt }],
      },
      config: {
        responseModalities: [Modality.IMAGE],
      },
    });

    if (response.candidates && response.candidates.length > 0) {
      const parts = response.candidates[0].content.parts;
      for (const part of parts) {
        if (part.inlineData) {
          return {
            imageData: part.inlineData.data,
            usageMetadata: response.usageMetadata as GeminiUsageMetadata | undefined,
          };
        }
      }
    }
    throw new Error("No image data found in the API response.");
  }

  const response = await ai.models.generateImages({
    model: model.apiModelId,
    prompt,
    config: {
      numberOfImages: 1,
      outputMimeType: model.outputMimeType ?? 'image/png',
      aspectRatio,
    },
  });

  if (response.generatedImages && response.generatedImages.length > 0) {
    const base64ImageBytes = response.generatedImages[0].image.imageBytes;
    return {
      imageData: base64ImageBytes,
      usageMetadata: (response as unknown).usageMetadata as GeminiUsageMetadata | undefined,
    };
  }

  throw new Error("No image was generated by the API.");
}

